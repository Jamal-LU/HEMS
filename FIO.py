# -*- coding: utf-8 -*-
"""FIO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jKihYj1AtMEYhsslMzj9SmFBzZDcdU5_
"""

import numpy as np
import csv
import matplotlib.pyplot as plt
import math
import random
import pandas as pd
from pyomo.opt import SolverFactory
from pyomo.core import Var
import pyomo.environ as en
import seaborn as sns
import time



for i in range(1):
    Month_test=month_t_1_new[i]
    DAY_test=day_t_1_new[i]
    pv=env.data_manager.get_series_pv_data(Month_test,DAY_test)
    PV_for_100_days.append(sum(pv))
    price=env.data_manager.get_series_price_data(Month_test,DAY_test)
    Price_for_100_days.append(sum(price))
    load=env.data_manager.get_series_electricity_cons_data(Month_test,DAY_test)
    Load_for_100_days.append(sum(load))
    Price_buy= np.array(price)
    Price_sell=Price_buy/2
    initial_battery =500*ES_SOC_1_new[i]
    initial_EV= 500* EV_SOC_1_new[i]
    #data
    Electriciy_buy =Price_buy
    Electriciy_sell=Price_sell
    load=np.array(load)
    PV = np.array(pv)
    # EV avaliable
    EV_avaliable = np.array([1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,1 ,1 ,1 ,1 ,1 ,1 ,1])
    # Temp outside

    ##################### Convert data to dictionary                     ############################################################
    Electriciy_sell_dict = dict(enumerate(Electriciy_sell))
    Electriciy_buy_dict = dict(enumerate(Electriciy_buy))
    EV_avaliable_dict =dict(enumerate(EV_avaliable))

    net = load-PV
    Post_Load = np.copy(load-PV)
    negLoad = np.copy(load-PV)
    for j,e in enumerate(net):
        if e>=0:
            negLoad[j]=0
        else:
            Post_Load[j]=0
    Post_Load_dict = dict(enumerate(Post_Load))
    neg_load_dict = dict(enumerate(negLoad))

    ###########################################################################################################################################################
    ##################### Model and Time                     ############################################################
    model = en.ConcreteModel()
    model.Time = en.RangeSet(0, len(net)-1)

    ###########################################################################################################################################################
    ##################### parameters                     ############################################################
    model.priceSell = en.Param(model.Time, initialize=Electriciy_sell_dict)
    model.priceBuy = en.Param(model.Time, initialize=Electriciy_buy_dict)
    model.posLoad = en.Param(model.Time, initialize=Post_Load_dict)
    model.negLoad = en.Param(model.Time, initialize=neg_load_dict)

    ####################### EV
    EV_Battery_capacity=16
    charging_power_limit_EV=3.3
    discharging_power_limit_EV=-3.3
    charging_efficiency_EV=0.95
    discharging_efficiency_EV=0.95
    Lower_capacity= 0.1 # 10%
    model.EV_avaliable = en.Param(model.Time, initialize=EV_avaliable_dict)
    model.EV_battery_effi_charg = en.Param(initialize = charging_efficiency_EV)
    model.EV_battery_effi_disch = en.Param(initialize = discharging_efficiency_EV)
    model.EV_charge_limit_battery = en.Param(initialize = charging_power_limit_EV)
    model.EV_discharge_limit_battery = en.Param(initialize = discharging_power_limit_EV)

    ####################### Battery
    Battery_capacity=10
    charging_power_limit=3
    discharging_power_limit=-3
    charging_efficiency=0.95
    discharging_efficiency=0.95
    model.battery_effi_charg = en.Param(initialize = charging_efficiency)
    model.battery_effi_disch = en.Param(initialize = discharging_efficiency)
    model.charge_limit_battery = en.Param(initialize = charging_power_limit)
    model.discharge_limit_battery = en.Param(initialize = discharging_power_limit)


    ###########################################################################################################################################################
    #####################                       Variables                     ############################################################

    ####################### Battery
    model.SOC = en.Var(model.Time, bounds=(Battery_capacity*Lower_capacity,Battery_capacity), initialize=Battery_capacity*Lower_capacity) #0
    model.posDeltaSOC = en.Var(model.Time, initialize=Battery_capacity*Lower_capacity) #1
    model.negDeltaSOC = en.Var(model.Time, initialize=Battery_capacity*Lower_capacity) #2
    model.charging_battery_from_grid = en.Var(model.Time, bounds=(0,charging_power_limit*(1.)), initialize=0) #3
    model.charging_battery_from_PV = en.Var(model.Time, bounds=(0,charging_power_limit*(1.)), initialize=0) #4
    model.discharging_battery_to_home = en.Var(model.Time, bounds=(discharging_power_limit*(1.),0), initialize=0) #5
    model.discharging_battery_to_grid = en.Var(model.Time, bounds=(discharging_power_limit*(1.),0), initialize=0) #6
    model.charing_battery_bool=en.Var(model.Time,within=en.Boolean) #7
    model.discharing_battery_bool=en.Var(model.Time,within=en.Boolean,initialize=0) #8

    ####################### EV
    model.EV_SOC = en.Var(model.Time, bounds=(EV_Battery_capacity*Lower_capacity,EV_Battery_capacity), initialize=EV_Battery_capacity*Lower_capacity) #9
    model.EV_posDeltaSOC = en.Var(model.Time, initialize=EV_Battery_capacity*Lower_capacity) #10
    model.EV_negDeltaSOC = en.Var(model.Time, initialize=EV_Battery_capacity*Lower_capacity) #11
    model.EV_charging_battery_from_grid = en.Var(model.Time, bounds=(0,charging_power_limit_EV*(1.)), initialize=0) #12
    model.EV_charging_battery_from_PV = en.Var(model.Time, bounds=(0,charging_power_limit_EV*(1.)), initialize=0) #13
    model.EV_discharging_battery_to_home = en.Var(model.Time, bounds=(discharging_power_limit_EV*(1.),0), initialize=0) #14
    model.EV_discharging_battery_to_grid = en.Var(model.Time, bounds=(discharging_power_limit_EV*(1.),0), initialize=0) #15
    model.EV_charing_battery_bool=en.Var(model.Time,within=en.Boolean) #16
    model.EV_discharing_battery_bool=en.Var(model.Time,within=en.Boolean,initialize=0) #17

    ####################### total Power
    model.total_power_buy_grid = en.Var(model.Time, initialize=Post_Load_dict) #21
    model.total_power_sell_grid = en.Var(model.Time, initialize=neg_load_dict) #22

    ###########################################################################################################################################################
    #####################                       Opt function                     ############################################################
    def Obj_fn(m):
        return sum((model.priceBuy[i]*model.total_power_buy_grid[i]) + (model.priceSell[i]*model.total_power_sell_grid[i]) for i in model.Time)
    model.total_cost = en.Objective(rule=Obj_fn,sense=en.minimize)


    ##################### Battery (A)    ############################################################

    def SOC_rule(m,i):
        if i==0:
            return (model.SOC[i] == model.posDeltaSOC[i]+initial_battery+model.negDeltaSOC[i])
        else:
            return (model.SOC[i] == model.SOC[i-1]+model.posDeltaSOC[i]+model.negDeltaSOC[i])
    model.Batt_SOC = en.Constraint(model.Time,rule=SOC_rule)


    def Bool_char_rule_1(m,i):
        bigM=500000
        return((model.posDeltaSOC[i])>=-bigM*(model.charing_battery_bool[i]))
    model.Batt_ch1=en.Constraint(model.Time,rule=Bool_char_rule_1)

    def Bool_char_rule_2(m,i):
        bigM=500000
        return((model.posDeltaSOC[i])<=0+bigM*(1-model.discharing_battery_bool[i]))
    model.Batt_ch2=en.Constraint(model.Time,rule=Bool_char_rule_2)

    def Bool_char_rule_3(m,i):
        bigM=500000
        return((model.negDeltaSOC[i])<=bigM*(model.discharing_battery_bool[i]))
    model.Batt_cd3=en.Constraint(model.Time,rule=Bool_char_rule_3)

    def Bool_char_rule_4(m,i):
        bigM=500000
        return((model.negDeltaSOC[i])>=0-bigM*(1-model.charing_battery_bool[i]))
    model.Batt_cd4=en.Constraint(model.Time,rule=Bool_char_rule_4)

    def Batt_char_dis(m,i):
        return (model.charing_battery_bool[i]+model.discharing_battery_bool[i],1)
    model.Batt_char_dis=en.Constraint(model.Time,rule=Batt_char_dis)


    ##################### EV (A)     ############################################################
    def SOC_rule_EV(m,i):
        if i==0:
            return (model.EV_SOC[i] == model.EV_posDeltaSOC[i]+initial_EV+model.EV_negDeltaSOC[i])
        else:
            return (model.EV_SOC[i] == model.EV_SOC[i-1]+model.EV_posDeltaSOC[i]+model.EV_negDeltaSOC[i])
    # then we specify that this constraint is indexed by time
    model.Batt_SOC_EV = en.Constraint(model.Time,rule=SOC_rule_EV)

    def Travel_constraint(m,i):
        if i==8:
            return (model.EV_SOC[i] >= 400.0)
        else:
          return en.Constraint.Skip
    model.Travel_constraint_EV = en.Constraint(model.Time,rule=Travel_constraint)

    def Bool_char_rule_1_EV(m,i):
        bigM=500000
        return((model.EV_posDeltaSOC[i])>=(-bigM*(model.EV_charing_battery_bool[i])*model.EV_avaliable[i]))
    model.Batt_ch1_EV=en.Constraint(model.Time,rule=Bool_char_rule_1_EV)

    def Bool_char_rule_2_EV(m,i):
        bigM=500000
        return((model.EV_posDeltaSOC[i])<=0+bigM*((1-model.EV_discharing_battery_bool[i])*model.EV_avaliable[i]))
    model.Batt_ch2_EV=en.Constraint(model.Time,rule=Bool_char_rule_2_EV)

    def Bool_char_rule_3_EV(m,i):
        bigM=500000
        return((model.EV_negDeltaSOC[i])<=bigM*((model.EV_discharing_battery_bool[i])*model.EV_avaliable[i]))
    model.Batt_cd3_EV=en.Constraint(model.Time,rule=Bool_char_rule_3_EV)

    def Bool_char_rule_4_EV(m,i):
        bigM=500000
        return((model.EV_negDeltaSOC[i])>=0-bigM*((1-model.EV_charing_battery_bool[i])*model.EV_avaliable[i]))
    model.Batt_cd4_EV=en.Constraint(model.Time,rule=Bool_char_rule_4_EV)

    def Batt_char_dis_EV(m,i):
        return (model.EV_charing_battery_bool[i]+model.EV_discharing_battery_bool[i],1)
    model.Batt_char_dis_EV=en.Constraint(model.Time,rule=Batt_char_dis_EV)



    ##################### Battery (B)    ############################################################
    def Charging_effiecy(m,i):
        return (model.charging_battery_from_grid[i]+model.charging_battery_from_PV[i]) == model.posDeltaSOC[i]/model.battery_effi_charg
    model.Charging_effiecy = en.Constraint(model.Time, rule=Charging_effiecy)
    # ensure discharging eff multiplied
    def DisCharging_effiecy(m,i):
        return (model.discharging_battery_to_home[i]+model.discharging_battery_to_grid[i]) == model.negDeltaSOC[i]*model.battery_effi_disch
    model.DisCharging_effiecy = en.Constraint(model.Time, rule=DisCharging_effiecy)

    # ensure charging rate obeyed
    def Charging_limit(m,i):
        return (model.charging_battery_from_grid[i]+model.charging_battery_from_PV[i])<=model.charge_limit_battery
    model.Charging_limit_cons = en.Constraint(model.Time, rule=Charging_limit)
    # ensure DIScharging rate obeyed
    def DisCharging_limit(m,i):
        return (model.discharging_battery_to_home[i]+model.discharging_battery_to_grid[i])>=model.discharge_limit_battery
    model.dischargingLimit_cons = en.Constraint(model.Time, rule=DisCharging_limit)

    ##################### EV (B)     ############################################################
    def Charging_effiecy_EV_Con(m,i):
        return (model.EV_charging_battery_from_grid[i]+model.EV_charging_battery_from_PV[i]) == model.EV_posDeltaSOC[i]/model.EV_battery_effi_charg
    model.Charging_effiecy_EV_Con_1 = en.Constraint(model.Time, rule=Charging_effiecy_EV_Con)
    # ensure discharging eff multiplied
    def DisCharging_effiecy_EV_Con(m,i):
        return (model.EV_discharging_battery_to_home[i]+model.EV_discharging_battery_to_grid[i]) == model.EV_negDeltaSOC[i]*model.EV_battery_effi_disch
    model.DisCharging_effiecy_EV_Con_1 = en.Constraint(model.Time, rule=DisCharging_effiecy_EV_Con)

    # ensure charging rate obeyed
    def Charging_limit_EV_Con(m,i):
        return (model.EV_charging_battery_from_grid[i]+model.EV_charging_battery_from_PV[i])<=model.EV_charge_limit_battery
    model.Charging_limit_EV_Con_1 = en.Constraint(model.Time, rule=Charging_limit_EV_Con)
    # ensure DIScharging rate obeyed
    def DisCharging_limit_EV_Con(m,i):
        return (model.EV_discharging_battery_to_home[i]+model.EV_discharging_battery_to_grid[i])>=model.EV_discharge_limit_battery
    model.DisCharging_limit_EV_Con_1 = en.Constraint(model.Time, rule=DisCharging_limit_EV_Con)


    ####################### EV + Battery ##########################
    def Chaging_battery_EV_from_home_constraint(m,i):
        return model.charging_battery_from_PV[i]+ model.EV_charging_battery_from_PV[i]<=-model.negLoad[i]
    model.Chaging_battery_from_home_constraint = en.Constraint(model.Time, rule=Chaging_battery_EV_from_home_constraint)
    # ensure that negEOutLocal cannot exceed local demand
    def DisChaging_battery_EV_to_home_constraint(m,i):
        return model.discharging_battery_to_home[i]+model.EV_discharging_battery_to_home[i]>=-model.posLoad[i]
    model.DisChaging_battery_to_home_constraint = en.Constraint(model.Time, rule=DisChaging_battery_EV_to_home_constraint)

    ####################### total Power ##########################
    def Total_power_buy_from_grid_const(m,i):
        Cost_pos_battery= model.charging_battery_from_grid[i]+model.discharging_battery_to_home[i]
        Cost_pos_EV= model.EV_charging_battery_from_grid[i]+model.EV_discharging_battery_to_home[i]
        return model.total_power_buy_grid[i] == model.posLoad[i]+Cost_pos_battery+Cost_pos_EV
    model.Total_power_buy_from_grid_const = en.Constraint(model.Time,rule=Total_power_buy_from_grid_const)

    # calculate export
    def Total_power_sell_to_grid_const(m,i):
        Cost_Neg_Battery=model.charging_battery_from_PV[i]+model.discharging_battery_to_grid[i]
        Cost_Neg_EV=model.EV_charging_battery_from_PV[i]+model.EV_discharging_battery_to_grid[i]
        return model.total_power_sell_grid[i] == model.negLoad[i]+Cost_Neg_Battery+Cost_Neg_EV
    model.Total_power_sell_to_grid_const = en.Constraint(model.Time,rule=Total_power_sell_to_grid_const)

    opt= SolverFactory('glpk',executable='/usr/bin/glpsol') # GNU Linear Programming Kit
    t = time.time()
    results = opt.solve(model)
    elapsed = time.time() - t
    #print ('Time elapsed:', elapsed)

    j = 0
    for v in model.component_objects(Var, active=True):
        #print (j, v.getname())
        j+=1

    outputVars = np.zeros((23,len(Electriciy_sell)))

    j = 0
    for v in model.component_objects(Var, active=True):
        #print (v.getname())
        #print varobject.get_values()
        varobject = getattr(model, str(v))
        for index in varobject:
            outputVars[j,index] = varobject[index].value
        j+=1
        if j>=23:
            break


    # get the total cost
    cost_electricity = np.sum([(Electriciy_buy[i]*outputVars[18,i] + Electriciy_sell[i]*outputVars[19,i]) for i in range(len(Electriciy_buy))])